name: Deploy to Ubuntu Server

on:
  push:
    branches:
      - main  # Deploy when pushing to main branch
  workflow_dispatch:  # Allow manual deployment

jobs:
  deploy:
    name: Deploy Application
    runs-on: ubuntu-latest
    environment: Production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H ${{ secrets.SERVER_HOST }} >> ~/.ssh/known_hosts

      - name: Create .env file
        run: |
          cat > .env << EOF
          # Database Configuration
          POSTGRES_USER=${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          POSTGRES_DB=${{ secrets.POSTGRES_DB }}
          POSTGRES_URL=postgres://${{ secrets.POSTGRES_USER }}:${{ secrets.POSTGRES_PASSWORD }}@postgres:5432/${{ secrets.POSTGRES_DB }}

          # API Service
          PORT=3000
          WEB_URL=${{ secrets.WEB_URL }}
          BOT_WEBHOOK_URL=${{ secrets.BOT_WEBHOOK_URL }}
          API_WEBHOOK_URL=${{ secrets.API_WEBHOOK_URL }}
          CLIENT_ID=${{ secrets.CLIENT_ID }}
          CLIENT_SECRET=${{ secrets.CLIENT_SECRET }}
          NODE_ENV=production

          # Bot Service
          DISCORD_TOKEN=${{ secrets.DISCORD_TOKEN }}
          BOT_PREFIX=${{ secrets.BOT_PREFIX }}
          BOT_OWNER=${{ secrets.BOT_OWNER }}
          SCORE_GUILD=${{ secrets.SCORE_GUILD }}

          # Optional Third-Party API Keys
          GOOGLE_SEARCH_KEY=${{ secrets.GOOGLE_SEARCH_KEY }}
          GOOGLE_ENGINE_KEY=${{ secrets.GOOGLE_ENGINE_KEY }}
          SERVICE_ACCOUNT_EMAIL=${{ secrets.SERVICE_ACCOUNT_EMAIL }}
          SERVICE_ACCOUNT_KEY=${{ secrets.SERVICE_ACCOUNT_KEY }}
          SPREADSHEET_ID=${{ secrets.SPREADSHEET_ID }}
          IMGUR_CLIENT_ID=${{ secrets.IMGUR_CLIENT_ID }}
          PASTEE_KEY=${{ secrets.PASTEE_KEY }}
          OPEN_MOVIE_DB_KEY=${{ secrets.OPEN_MOVIE_DB_KEY }}
          COMICVINE_KEY=${{ secrets.COMICVINE_KEY }}
          WEBSTER_DICTIONARY_KEY=${{ secrets.WEBSTER_DICTIONARY_KEY }}
          WEBSTER_THESAURUS_KEY=${{ secrets.WEBSTER_THESAURUS_KEY }}

          # Dashboard Service
          NEXT_PUBLIC_API_URL=${{ secrets.NEXT_PUBLIC_API_URL }}
          NEXT_PUBLIC_WEB_URL=${{ secrets.NEXT_PUBLIC_WEB_URL }}
          NEXT_PUBLIC_CLIENT_ID=${{ secrets.NEXT_PUBLIC_CLIENT_ID }}
          NEXT_PUBLIC_BOT_AVATAR=${{ secrets.NEXT_PUBLIC_BOT_AVATAR }}
          EOF

      - name: Deploy to server
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          # Create deployment directory if it doesn't exist
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST "mkdir -p $DEPLOY_PATH"
          
          # Copy files to server (excluding node_modules, .git, etc.)
          rsync -avz --delete \
            --exclude 'node_modules' \
            --exclude '.git' \
            --exclude '.next' \
            --exclude 'dist' \
            --exclude 'build' \
            --exclude '.env.local' \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            ./ $SERVER_USER@$SERVER_HOST:$DEPLOY_PATH/
          
          # Copy .env file
          scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no .env $SERVER_USER@$SERVER_HOST:$DEPLOY_PATH/.env

      - name: Start services on server
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST << 'ENDSSH'
            cd ${{ secrets.DEPLOY_PATH }}
            
            # Pull latest images and rebuild
            docker compose -f docker-compose.prod.yml pull
            docker compose -f docker-compose.prod.yml build --no-cache
            
            # Stop old containers and start new ones
            docker compose -f docker-compose.prod.yml down
            docker compose -f docker-compose.prod.yml up -d
            
            # Clean up old images and containers
            docker system prune -f
            
            # Show running containers
            docker compose -f docker-compose.prod.yml ps
          ENDSSH

      - name: Verify deployment
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SERVER_USER: ${{ secrets.SERVER_USER }}
          SERVER_HOST: ${{ secrets.SERVER_HOST }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no $SERVER_USER@$SERVER_HOST << 'ENDSSH'
            cd ${{ secrets.DEPLOY_PATH }}
            
            echo "=== Container Status ==="
            docker compose -f docker-compose.prod.yml ps
            
            echo -e "\n=== Recent Logs ==="
            docker compose -f docker-compose.prod.yml logs --tail=50
          ENDSSH

      - name: Cleanup
        if: always()
        run: |
          rm -f ~/.ssh/deploy_key
          rm -f .env
